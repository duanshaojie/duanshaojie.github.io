---
title: JVM学习系列-运行时内存分配
tags: JVM
categories: java
---

#### 前言

​	最近没什么状态，也没怎么打理博客。

​	想了想，有些事，既然选择了，就走下去吧~

​	JVM系列，算是边看边记，如若有误，还望海涵 :-)

<!--more-->

​	java虚拟机在运行时会将内存划分为不用区域，详见下图：

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1513657456100&di=bf3a74648113c01743bd87068c019616&imgtype=0&src=http%3A%2F%2Fimages.cnitblog.com%2Fblog%2F412519%2F201410%2F160837090606014.png)



1. #### 堆

   ​	Java堆是JVM管理的最大的一块内存，因为几乎所有的对象内存空间都在Heap中分配，所以是线程共享的；所有的对象都在Heap中，所以GC进行垃圾回收最多的地方也是堆；

   ​

2. #### 方法区

   ​	方法区存储的为被JVM加载的类，常量，静态变量，即时编译后的代码等数据；

   ​	方法区也是线程共享的；

   - ##### 运行时常量池

     用于存放编译器形成的各种字面量和符号引用，这部分内容将在类加载后进入运行时常量池中存放

     ​

3. #### 虚拟机栈

   ​	虚拟栈描述的是java方法执行时的内存模型（JMM），每个方法在执行的时候会创建一个栈帧（stack frame），栈帧的数据结构包括局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从开始执行到退出的过程，及对应着栈帧在虚拟机栈中入栈到出栈的过程

   ​	因为每一个线程都有一个线程栈，线程栈保存了线程运行时候的变量信息，而当线程获取对象的值时的过程是这样的（通过对象引用找到存在Heap中的对象 - > 将对象的值load到线程本地内存中）,而对该对象的赋值，其实只是对本地内存中的对象副本的操作，堆中的对象还是原来的对象，直到线程退出之前的某个时刻，才会将副本中的值写入堆中~

4. #### 本地方法栈

   ​	与虚拟机栈作用类似，区别是虚拟机栈为执行字节码服务，而本地方法栈为虚拟机使用到的native方法服务。由于虚拟机规范中没有对本地方法栈中使用的语言、数据结构做出强制规定，具体的虚拟机可以自由实现。Sun HotSpot虚拟机直接把虚拟机栈和本地方法栈合二为一。本地方法栈也会抛出stackOverFlow和OOM异常。

   ​

5. #### 程序计数器

   ​	当前线程所执行的字节码的行号指示器，字节码解释器在工作时通过改变计数器的值来选取下一条需要执行的字节码指令

